# 02. 기술 스택 및 이유

이 프로젝트는 작지만 현대적이고 견고한 파이프라인 구축을 최우선으로 생각하고 있습니다. 문서에서 후술할 기술 스택들은 이 목표를 중심으로 선정되었으며 그 외의 선정 이유 또한 본 문서에서 상세하게 설명합니다.

## [`uv`](https://github.com/astral-sh/uv) - **가상환경 및 패키지 관리**

### 선택한 이유

Python 가상환경의 경우 선택지가 아주 다양하거나 편리하지는 않은 것으로 알고 있습니다. 기존에는 `venv`, `poetry` 등을 써왔지만 이번 프로젝트의 경우, 파이프라인의 CI/CD 속도와 로컬 개발 생산성을 극대화하기 위해 `uv`를 채택하였습니다.

가장 큰 장점은 익숙한 가상 환경인 `poetry`와 `pip`같은 패키지 관리자 대비 [수십 배 빠른 의존성 설치 속도](https://github.com/astral-sh/uv/blob/main/BENCHMARKS.md)입니다. 자동화된 CI 파이프라인이 실행될 때마다 즉각적인 테스트 결과를 얻을 수 있어 TDD 워크플로우의 효율을 극대화합니다. 추가로 `uv sync`와 `uv run` 등의 명령어는 `poetry`와도 비슷하여 사용하기에 편리했습니다.

### 대안

**`Poetry`**

기존에 가장 많이 사용해 익숙한 가상환경 관리자입니다. 사용자 규모나 안정성 측면에서 `uv`보다 확실하게 앞서지만, 이번에는 _'작고 빠른'_, _'현대적'_ 이라는 목표로 빠른 속도의 CI 파이프라인을 구축하고자 선택하지 않았습니다.

`uv`의 경우 현재 기준(2025.11) 1.0 릴리즈가 되지 않은 상태입니다. 그만큼 리스크가 없지는 않지만, Ruff 툴체인의 일부로 Astral에서 개발중이라는 점, 속도 면에서 압도적으로 빠르다는 점을 고려해 Python에서의 개발 편의성을 극대화할 수 있을 것이라 생각합니다.

## Github Actions

### 선택한 이유

Github Actions는 Github를 이미 표준처럼 쓰고 있는 상황에서 쓰지 않을 이유가 없습니다. Github와의 통합을 포함해서, 이를 대시보드로 보여주고, 무료이며, 워크플로우 정의가 쉽고 다양한 점 등이 장점으로 느껴집니다.

특히 TDD를 채택한 이상, 테스트 코드와의 통합이 원활하고 환경 변수 등의 관리가 Github와 연동된다는 점도 편리한 점입니다. 추가적으로 현재 ci 파이프라인에서는 린팅과 테스트를 병렬 처리하고, 유닛 테스트와 통합 테스트를 직렬로 처리하는 등의 플로우 정의도 쉬우며 `uv`가 pip 패키지를 가져올 때 캐싱 처리도 되어 시간을 더욱 단축시킬 수 있다는 점도 좋은 것 같습니다.

### 대안

**`Jenkins`**

비교적 작은 개인 프로젝트인 만큼, 다른 CI/CD 도구와 비교할 여지가 크게 없었는데요. 대표적으로 쓰이는 `Jenkins`가 있지만 운영 시 복잡도는 비교가 불가능할 만큼 높으며, 유지 비용 또한 생기게 됩니다. 사실상 업계 표준이며, 유연하고 확장성이 높다는 장점이 있지만 그 부분이 필요한 애플리케이션이 아닌 만큼(토이 프로젝트라면 대부분 그렇다고 생각합니다) 도입할 이유를 찾는 것이 더 어려운 것 같습니다.

**`GitLab Ci/CD`, `CircleCI`**

GitLab을 쓴다면 고려해 볼 만한 옵션입니다. Github Actions보다 더 많은 기능들을 제공한다고 알려져있고, 특히 엔터프라이즈급 기능에서 차이가 많이 나는 것으로 알고 있습니다. 다만 제 프로젝트와는 겹치는 것이 하나도 없으므로 후보군에서 제외합니다.

`CircleCI`는 흔히 `Docker`와 `K8s`와의 통합에서 강력한 이점을 가진다고 알고 있습니다. 유료 플랜이 존재하지만 무료 플랜의 수준에서 충분한 경우가 많고 언급했다시피 컨테이너 환경에서는 더 적합한 툴이지만 현재 시점인 애플리케이션 완성 이전에 컨테이너화 계획은 없으며, 앞으로도 Github Actions의 빌드 과정에서 심각한 병목이 발생하지 않는 이상, 바꿔야 할 필요는 없습니다.

## `pytest`

### 선택한 이유

`pytest`는 Python 내장 라이브러리는 아니지만, 테스트 옵션 중에서 사실상 표준처럼 여겨지는 라이브러리입니다.

문법이 간결하며, 함수 구조이기 때문에 테스트 코드의 이해가 쉽고 간단하며 명확하게 작성됩니다. 이는 개발 과정으로서의 목표로 삼고 있는 `TDD`에도 적합합니다. fixture, 테스트 설정 등의 방법도 간단하며, 테스트 실패 시에도 출력이 매우 상세하게 출력되고, 여러 플러그인을 통해 mock, coverage 등 테스팅에 필요한 기능들을 내장 기능처럼 제공합니다. 개인적으로는 간단한 테스트 함수 작성에서 가장 편리함을 많이 느낀 것 같습니다.

### 대안

\*\* `unittest`

Python에서 유닛 테스트의 내장 라이브러리로, 설치가 필요없습니다. 다만 객체 지향 스타일로 접근하기 때문에 작성 방법에서 `pytest`와 차이가 있으며 개인적으로는 직관적이지는 않다고 느꼈습니다. 더해서 앞에서 언급했던 `pytest`의 강력한 확장 기능들과 실패 시 디버깅과 같은, 많은 테스트를 실행하고 작성해야 하는 환경에서는 적합하지 않다고 생각합니다.

## `httpx`

<!-- `Dagster` 혹은 `Airflow` -->
